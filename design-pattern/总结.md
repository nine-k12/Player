抽象工厂
提供一个创建一系列或相关依赖对象的接口而无需指定它们具体的类

建造者
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

工厂方法
定义一个用于创建对象的接口，让子类决定实例化那一个类，工厂模式使一个类的实例化延迟到子类

原型模式
用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象

单例模式
一个类仅有一个实例，并提供一个访问它的全局访问点


创建型模式
隐藏了这些类的实例是如何被创建和放在一起，整个系统关于这些对象所知道的是由抽象类所定义的接口，这样，创建型模式在创建了什么，谁创建它，它是怎么被创建的，以及何时创想这些方面提供了很大的灵活性

当一个系统应该独立于它的产品创建、构成和表示时。应该考虑应用创建型模式，建立相应数目的原型并克隆它们通常比每次用合适的状态手工实例化该类更方便一些


对于一些类来说，一个实例很重要。一个全局变量可以使得一个对象被访问，但它不能防止客户实例化多个对象。单例模式让类自身负责保存它唯一的实例，这个类可以保证没有其他实例可以被创建，并且还提供一个访问该实例的方法。这样就使得对唯一的实例可以严格地控制客户怎样以及何时访问它。

---
适配器模式
将一个类的接口转换成客户希望的另一个接口

桥接模式
将抽象部分与它的实现部分分离，使它们可以独立的变化
如果能发现继承体系中，有两个甚至多个方向的变化，那么就解耦这些不同方向的变化，通过对象组合的方式，把两个角色之间的继承关系改为了组合的变化，从而使这两者可以应对各自对立的变化

组合模式
将对象组合成树形结构以表示"部分-整体"的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性

装饰器模式
动态的给一个对象添加一些额外的职责

外观模式
为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，使得子系统更加容易使用。

享元模式
运用共享技术有效的支持大量细粒度的对象

代理模式
为其他对象提供一种代理以控制对这对象的访问


代理对象代表一个单一对象而外观对象代表一个子系统：代理的客户对象无法直接访问目标对象，由代理提供对单独的目标对象的访问控制，而外观的客户对象可以直接访问子系统中的各个对象，但是通常由于外观对象提供对子系统各元件功能的简化的共同层次的调用接口

外观定义的是一个新的接口，而适配器则是复用一个原有的接口，适配器是使两个已有的接口协同工作，而外观则是为现存系统提供一个更为方便的访问接口

---

观察者模式
定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖与它的对象都得到通知并被自动更新

模板模式
定义一个操作的算法骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤

命令模式
将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化：可以对请求排队或记录请求日志，以及支持可撤销操作
将调用操作的对象与知道如何实现该操作的对象解耦，可以在这两者之间处理很多事，具体怎么处理在何时处理都不需要命令发送方关注

状态模式
允许一个对象在其内部发生改变时改变它的行为，让对象看起来似乎修改了它的类

职责链模式
使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些队象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止
有时会有多个对象可以处理一个请求，具体哪个对象处理该请求事先并不知道，要在运行时自动确定

解释器模式
定义文法的一种表示，并定义一个解释器，这个解释器使用尬表示来解释语言中的句子
如果一种特定类型的问题发生的频率足够高，那么就可以考虑将该问题的各个实例表述为一个简单语言中的句子，即通过构建一个解释器，该解释器解释这些句子来解决该问题

中介者模式
用一个中介对象来封装一系列对象的交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互
中介者充当一个中介以使组中的对象不再相互现实引用，这些对象仅知道中介者，从而减少了相互连接的数目

访问者模式
一个作用于某对象结构中的各元素的操作，它可以在不改变各元素的类的前提下定义作用于这些元素的新操作

策略模式
定义一系列算法，把它们一个个封装起来，并且使它们可以相互替换，本模式使得算法可以独立于使用它的客户而变化

备忘录模式
在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态

迭代器模式
提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示











